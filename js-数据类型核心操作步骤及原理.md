>## JS中的数据类型
> - 基本数据类型（值类型）
>     + number
>     + string
>     + boolean
>     + null
>     + undefined
> - 引用数据类型
>     + 对象
>         + { } 普通对象
>         + [ ]数组
>         + /^$/正则
>         + Math对象数据类型
>         + ...
>     + 函数
>        + function 普通函数
>        + 类
>        + ...

JS代码运行在浏览器当中，是因为浏览器给我们提供了一个供js执行的环境 -> `全局作用域(window/global)`

```
var a = 12;
var b = a;
b = 13;
console.log(a); //12

var o = { name : '我是对象' };
var p = o;
p.name = '吴';
console.log(o.name); //吴

var m = { name ： '我是m' };
var n = m;
n = { name : '我赋值n' };
console.log(m.name); // 我是m

function fn(){
    var total = null;
    var ary = Array.prototype.slice.call(arguments);
    return eval(ary.join('+'));
}
fn(12,23,23,123)
```
### 值类型

> 直接按值操作，例如a=12；直接把12这个值给变量a（让a变量喝12这个值建立了连接关系）

### 对象数据类型

> 在JS中遇到对象，会严格按照如下步骤操作：
> 1、浏览器为其开辟一个新的内存空间，为了方便后期可以找到这个空间，浏览器给空间分配一个16进制的地址
> 2、按照一定顺序，分别的把对象键值对存储到内存空间当中
> 3、把开辟内存的地址赋值给变量（或者其他的东西），以后变量就可以通过地址找到内存空间，然后进行一些操作

### 函数的操作

> 创建函数
> 1、先开一个新的内存空间（为其分配了一个16进制的地址）
> 2、把函数体中编写的js代码当作`字符串`存储到空间（函数只创建不执行没有意义）
> 3、把分配的地址赋值给声明的函数名（funciton fn 和 var fn操作原理其实相同，都是在当前作用域中声明了一个名字，两个名字是重复的）
> 
> 执行函数
> 目的：执行函数体中的代码
> 1、函数执行的时候，浏览器会形成一个新的私有作用域（只能执行函数体中的代码）供函数体中的代码执行
> 2、执行代码之前，先把创建函数存储的那些字符串变成真正的js表达式，按照从上到下的顺序在私有作用域中执行
> 
> 一个函数可以被执行N次，每一次执行相互之间互不干扰（后面会学习两者之间建立的渐接关系）
> 形成的私有作用域把函数体中的私有变量都包裹起来了（保护起来了），在私有作用域中操作私有变量和外界没关系，外界也无法直接操作私有变量，我们把函数执行形成的这种保护机制叫做`闭包`; 

### JS中的堆栈内存

> **栈内存**：
> 俗称叫作用域（全局作用域/私有作用域）

> - 为js代码提供执行的环境（执行js代码的地方）
> - 基本数据类型值是直接存放在栈内存中的
> 
> **堆内存**
> 存储引用数据类型的（相当于一个存储的仓库）

> - 对象存储的是键值对
> - 函数存储的是代码字符串

在项目中，我们的内存越少性能越好，我们需要把一些没用的内存处理掉
【堆内存】
var o = {}; 当前对象对应的堆内存被变量o占用着，堆内存是无法销毁的
o = 12; null空对象指针（不指向任何的堆内存），此时上一次的堆内存就没有被占用了，谷歌浏览器会在空闲时间把没有被占用的堆内存自动释放（销毁/回收）

【栈内存】
一般情况下，函数执行形成栈内存，函数执行完，浏览器会把形成的栈内存自动释放；有时候执行完成，栈内存不能被释放？
全局作用域在加载页面执行，在关掉页面时候销毁；













 
