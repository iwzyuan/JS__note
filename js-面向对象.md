##面向对象

###单例模式

> 在真实项目中，为了实现模块化开发或者团队协作开发，我们经常应用单例模式（一般业务逻辑部分的代码都是依托单例模式设计规划的）
`单例模式的由来`
> 很早以前，JS中都是值类型，没有引用数
据类型

```javascript
var name = 'wu';
var age = 19;
var sex = 女;
//=> 如果后面编写的代码，创建的变量或者函数名和之前一样，会把之前的值替换掉，真实项目中团队协作开发，如果是这样来处理，经常会导致相互代码的冲突:`全局变量污染`
```

> 后来JS中诞生了对象数据类型，解决了上面出现的污染冲突问题

```javascript
//=> 把描述同一件事物的特征或者属性，进行归纳汇总（放在一起），以此来避免全局变量之间的冲突
var person1 = {
    name : 'wu',
    age : 19,
    sex : '女
}

```

> 我们把对象数据类型实现：`把描述同一间事物的属性或者特征归纳汇总在一起，以此避免全局变量冲突问题`的方式和思想叫做：**`单例设计模式`**
```javascript
//=> 1. singleton不仅仅是对象名了，在单例模式中，singleton称之为" 命名空间（nameSpace）"
var singleton = {
    xxx:xxx
}
```
> 把描述同一件事物的属性或者方法存放在某一个命名空间下，多个命名空间中的属性和方法是互不干扰的

###使用单例模式实现模块儿化开发

> 模块化开发：在团队协作开发的时候我们经常会把一个复杂页面，按照具体的功能划分为几大块儿，然后分别去开发，这种模块划分的思想就是模块化开发思想
> 
> 真实项目中，我们可以使用单例模式（建议也使用单例模式）来实现模块儿化开发

##高级单例模式

> 基于JS高阶编程技巧`惰性思想`来实现的单例模式,并且可以把一些常用的设计模式（`命令模式，发布订阅模式，promise设计模式`）融合进来,最后清晰的规划业务逻辑代码，方便后期二次开发和维护，这种设计综合体就是高级单例模式，也是项目中最常应用的

```javascript
var searchmodel = (function (){
    function submit (){
        ...
    }
    return {
        init : function (){
        }
    }
})();
searchmodel.init();
```

##面向对象（OOP编程思想）

> 面向对象是编程思想（面向过程编程思想C语言）,JAVA、PHP、C#、C++、.net、JS...这些都是面向对象编程的
> HTML和CSS是标记语言不是编程语言，没有所谓的面向对象编程
> 后期学习LESS和SASS属于CSS预编译语言、旨在把CSS变为编程语言（面向对象）

对象、类、实例

> 对象：编程语言中的对象是一个泛指，万物皆对象（我们研究学习以及使用的都是对象）
> 类：把对象的具体细分（按照属性或者特征细分为一些类别）
> 实例：某一类中具体的事物

[实际生活中]

> 自然界中万物皆对象，我们为了认知自然界，我们会把自然界中的事物按照特征进行分类，例如我们可以分为

> - 动物类
>   + 人类
>       + 正常人
>       + 程序员
>   + 爬行动物类
>   + ...
> - 植物类
> - 微生物


----------

> JS本身就是基于面向对象创造出来的语言（所以他是面向对象编程），我们想学JS，首先也是给其进行分类，我们拿出某一类中的实例，进行学习和研究

###JS中常用的内置类

> - 关于数据类型的
>   + Number:每一个数字或者NaN都是它的一个实例
>   + String:字符串类
>   + Boolean：布尔类
>   + Null
>   + Undefined：浏览器屏蔽了我们操作Null或者undefined这个类
>   + Object：对象类，每一个对象数据类型都是它的实例
>       + Array：数组类
>       + RegExp：正则类
>       + Date：日期类
>   + Function：函数类，每一个函数都是它的一个实例
> 
> - 关于元素和元素集合的
>   + HTMLCollection：元素集合类(getElementsByTagName,getElementsByClassName,querySelectorAll)
>   + NodeList：节点集合类(getElementsByName,childNodes)
>   + HTMLDivElement
>   + HTMLElement
>   + Element
>   + Node
>   + EventTarget

###目前阶段学习面向对象对于我们的意义

> 研究数组：
> 1.创造一个数组类的实例。研究其基础语法和结构
> 2.如果想要研究数组具备的功能方法，我们只需要看Array/Object这些类上都赋予了它怎么样的方法
> document.getElementbyId它的上下文只能是document，其他不可以？因为：getElementById这个方法只有Document这个类才有，其他的类都没有，所以只有document这个作为Document的实例才能使用这个方法

###基于面向对象创建数据值
```javascript
var ary = []; //=>字面量创建方式
var ary = new Array(); //=> 严谨的基于面向对象（构造函数）方式创建一个数组
/*两种创建方式在核心意义上没有差别，都是创建Array这个类的一个实例，但是在语法上是有区别的
1）字面量创建方式传递进来什么，都是给数组每一项加入的内容
2）构造函数创建方式
new Array(10)//:创建一个长度为10的数组，数组中的每一项都是空*/
new Array('10') : //如果只传递一个实参，并且实参不是数字，相当于把当前值作为数组的第一项存储进来的
new Array('1','2','3') : //如果传递多个实参，不是设置长度，而是把传递的内容当作数组中的每一项存储起来

var obj = {age : 1}
var obj = new Object();//只用于创建空对象，需要键值对，自行添加


----------
var num = 12;//=> 字面量创建出来的是一个基本数据类型（但是也是Number的一个实例，可以调取Number赋予它的方法）
num.toFixed //: 就是Numer赋予它的方法,浏览器将12这个基本类型转换成实例类型

var num = new Number(12);//=> 构造函数方式创建出来的也是Number的一个实例（也可以使用Number赋予它的方法），但是获取的结果是对象数据类型
```

###构造函数设计模式（constructor）

> 使用构造函数方式，主要是为了创建类和实例的，也就是基于面向对象编程思想来实现一些需求的处理
> 在JS中当我们使用`new xxx()`执行函数的时候，此时的函数就不是普通的函数了，而是变为一个类，返回的结果叫做当前的类的实例，我们这种new xxx执行的方式成为`构造函数设计模式`

```javascript
function Fn(){
}
var fn = new Fn();//=> Fn是一个类，fn就是Fn类下的一个实例
```

> 普通函数执行 VS 构造函数执行

> - 普通函数执行：
> 1.开辟一个私有作用域
> 2.形参赋值
> 3.变量提升
> 4.代码自伤而下执行，return后面的值就是当前函数返回的结果
> 5.栈内存释放不释放

```javascript
function fn(num){
    this.num = num;//=> this:window 给全局对象增加一个num的属性名，属性值是10
    var total = null;
    total+=num;
    return total;
}
fn(10);//=> 10
```

> - 构造函数执行
> 1.首先和普通函数执行一样，也需要开辟一个新的私有作用域
> 2.在私有作用域中完成类似于普通函数的操作：形参赋值及变量提升
> 3.在代码自上而下执行之前，构造函数有属于自己比较特殊的操作：`浏览器会在当前的作用域中，默认创建一个对象数据类型的值，并且会让当前函数中的执行主体（this）指向创建的这个对象`
> 4.像普通函数一样，代码自上而下执行：`this.xxx = xxx这都是再给当前创建的这个对象增加属性名和属性值`
> 5.代码执行完成后，即使函数中没有写return在构造函数模式中，`浏览器会默认的把创建的对象返回到函数的外面`
> 
> 构造函数执行，既具备普通函数执行的一面，也同时具备自己独有的一些操作：`在构造函数执行期间，浏览器默认创建的对象（也就是函数体中的this）就是当前这个类的一个实例，浏览器会把默认创建的实例返回，所以我们说：new Fn()执行，Fn是一个类，返回的结果是Fn这个类的一个实例`

```javascript
function Fn(num){
    //=> 在构造函数模式中，方法体中出现的this是当前类的一个实例（this.xxx都是在给当前实例增加一些私有的属性）
    this.num = num;
}
var f = new Fn(10);
```                

###深入理解构造函数执行的步骤

> 当构造函数或者类，执行的时候不需要传递任何的实参值，此时我们是否加小括号就不重要了（不传递实参的时候，小括号可以省略）
> 构造函数执行，同时具备了普通函数执行的一面，但是和实例相关的，只有自己特殊的一面才相关（this.xxx = xxx相当于给当前实例增加的私有属性）私有变量和实例无关
> 通过类创建出来的每一个实例都是单独的个体（堆内存空间），实例和实例之间是不相同并且独立互不影响的(市面上部分开发是把这种模式叫做单例模式，这种是错误的，JS中这种模式叫做构造函数设计模式)
> 在构造函数体当中，通过this.xxx给实例设置的属性都是当前实例的私有属性
> 当构造函数体中我们自己手动的设置了return （默认返回的是实例：对象类型值，对返回结果没有任何影响）但如果返回的是引用数据类型的值，会把默认返回的实例替换掉

```javascript
function Fn(){
    var num = 100;
    this.name = 200;
    this.sum = function (){
    }
}
var f1 = new Fn();
var f2 = new Fn();

//=> 私有变量和实例没关系
console.log(f1.num) //=> undefined
console.log(f1.name) //=> 200

//=> 不同的实例是不同的空间地址
f1 === f2:false
f1.sum === f2.sum:false

function sum(){
    this.name = 'aaa'
    return '10'
}
var f = new sum();//=> 依然是当前类的一个实例

function sum2(){
    this.name = 'aaa'
    return {name : 'bbb'}
}
var f = new sum2();//=> 不再是Fn的实例，而是手动返回的对象
```


